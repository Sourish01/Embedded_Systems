# fault_page.py
import customtkinter as ctk
from base_page import BasePage
from dtc_definitions import DTC_DATABASE, SEVERITY_COLORS
from fault_manager import FaultManager

class FaultPage(BasePage):
    def __init__(self, parent, controller):
        super().__init__(parent, controller)
        self.fault_manager = FaultManager()
        self.serial_handler = controller.serial_handler if hasattr(controller, 'serial_handler') else None
        
        # Configure grid layout
        self.middle_frame.grid_rowconfigure(0, weight=0)  # Header
        self.middle_frame.grid_rowconfigure(1, weight=1)  # Main content
        self.middle_frame.grid_columnconfigure(0, weight=1)
        
        # Header frame
        header_frame = ctk.CTkFrame(self.middle_frame, height=60)
        header_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=5)
        
        ctk.CTkLabel(
            header_frame, 
            text="FAULT DIAGNOSTICS",
            font=("Helvetica", 20, "bold"),
            text_color="#2ecc71"
        ).pack(side="left", padx=20)
        
        # Status indicators
        status_frame = ctk.CTkFrame(header_frame, fg_color="transparent")
        status_frame.pack(side="right", padx=20)
        
        self.active_count = ctk.CTkLabel(
            status_frame,
            text="Active: 0",
            font=("Helvetica", 14),
            text_color="#e74c3c"
        )
        self.active_count.pack(side="left", padx=10)
        
        self.stored_count = ctk.CTkLabel(
            status_frame,
            text="Stored: 0",
            font=("Helvetica", 14),
            text_color="#f39c12"
        )
        self.stored_count.pack(side="left", padx=10)
        
        # Main content frame
        content_frame = ctk.CTkFrame(self.middle_frame)
        content_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=5)
        content_frame.grid_columnconfigure(0, weight=1)
        content_frame.grid_rowconfigure(1, weight=1)
        
        # Input panel
        input_panel = ctk.CTkFrame(content_frame, height=80)
        input_panel.grid(row=0, column=0, sticky="ew", pady=5)
        
        self.dropdown = ctk.CTkOptionMenu(
            input_panel,
            values=list(DTC_DATABASE.keys()),
            font=("Helvetica", 14),
            dropdown_font=("Helvetica", 12),
            width=300,
            dynamic_resizing=True
        )
        self.dropdown.pack(side="left", padx=10, pady=10)
        
        ctk.CTkButton(
            input_panel,
            text="Inject Fault",
            command=self.handle_inject,
            font=("Helvetica", 14),
            fg_color="#3498db",
            hover_color="#2980b9",
            width=120
        ).pack(side="left", padx=10)
        
        # DTC display area
        display_frame = ctk.CTkFrame(content_frame)
        display_frame.grid(row=1, column=0, sticky="nsew", pady=5)
        display_frame.grid_columnconfigure(0, weight=1)
        display_frame.grid_columnconfigure(1, weight=1)
        display_frame.grid_rowconfigure(0, weight=1)
        
        # Active DTCs
        active_frame = ctk.CTkFrame(display_frame)
        active_frame.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        
        active_header = ctk.CTkFrame(active_frame, height=40)
        active_header.pack(fill="x")
        
        ctk.CTkLabel(
            active_header,
            text="ACTIVE DTCs",
            font=("Helvetica", 16, "bold"),
            text_color="#e74c3c"
        ).pack(side="left", padx=10)
        
        self.active_list = ctk.CTkTextbox(
            active_frame,
            font=("Consolas", 14),
            height=300,
            wrap="word",
            activate_scrollbars=True
        )
        self.active_list.pack(expand=True, fill="both", padx=5, pady=5)
        
        # Stored DTCs
        stored_frame = ctk.CTkFrame(display_frame)
        stored_frame.grid(row=0, column=1, sticky="nsew", padx=5, pady=5)
        
        stored_header = ctk.CTkFrame(stored_frame, height=40)
        stored_header.pack(fill="x")
        
        ctk.CTkLabel(
            stored_header,
            text="STORED DTCs",
            font=("Helvetica", 16, "bold"),
            text_color="#f39c12"
        ).pack(side="left", padx=10)
        
        self.search_entry = ctk.CTkEntry(
            stored_header,
            placeholder_text="Search DTCs...",
            width=180,
            font=("Helvetica", 12)
        )
        self.search_entry.pack(side="right", padx=10)
        self.search_entry.bind("<KeyRelease>", self.filter_stored_dtcs)
        
        self.stored_list = ctk.CTkTextbox(
            stored_frame,
            font=("Consolas", 14),
            height=300,
            wrap="word",
            activate_scrollbars=True
        )
        self.stored_list.pack(expand=True, fill="both", padx=5, pady=5)
        
        # Control buttons
        control_frame = ctk.CTkFrame(content_frame, height=60)
        control_frame.grid(row=2, column=0, sticky="ew", pady=5)
        
        ctk.CTkButton(
            control_frame,
            text="🔄 Refresh",
            command=self.update_ui,
            font=("Helvetica", 14),
            width=120
        ).pack(side="left", padx=10)
        
        ctk.CTkButton(
            control_frame,
            text="➡ Move to Stored",
            command=self.move_selected_dtc,
            font=("Helvetica", 14),
            fg_color="#9b59b6",
            hover_color="#8e44ad",
            width=150
        ).pack(side="left", padx=10)
        
        ctk.CTkButton(
            control_frame,
            text="❌ Clear Active",
            command=self.clear_active,
            font=("Helvetica", 14),
            fg_color="#e74c3c",
            hover_color="#c0392b",
            width=120
        ).pack(side="left", padx=10)
        
        ctk.CTkButton(
            control_frame,
            text="🗑️ Clear Stored",
            command=self.clear_stored,
            font=("Helvetica", 14),
            fg_color="#f39c12",
            hover_color="#d35400",
            width=120
        ).pack(side="left", padx=10)
        
        # Initialize
        self.update_ui()

    def move_selected_dtc(self):
        """Move selected DTC from active to stored list (max 3 stored DTCs)"""
        content = self.active_list.get("1.0", "end").strip().splitlines()
        if content:
            last_line = content[-1]
            code = last_line.split(":")[0]
            
            # Enforce 3 DTC limit
            if len(self.fault_manager.stored_dtc) >= 3:
                oldest_dtc = min(self.fault_manager.stored_dtc.items(), 
                                key=lambda x: x[1]['timestamp'])[0]
                del self.fault_manager.stored_dtc[oldest_dtc]
            
            self.fault_manager.move_to_stored(code)
            self.update_ui()
            
            # Send serial notification
            if self.serial_handler:
                self.serial_handler.send(bytes([0x03, 0x01]))  # Mode 03 - Stored DTCs

    def handle_inject(self):
        code = self.dropdown.get()
        self.inject_fault(code)
        
        # Visual feedback
        self.dropdown.configure(fg_color="#2ecc71")
        self.after(300, lambda: self.dropdown.configure(fg_color=["#3B8ED0", "#1F6AA5"]))

    def inject_fault(self, code):
        self.fault_manager.inject_fault(code)
        self.update_ui()

    def clear_active(self):
        self.fault_manager.clear_active()
        self.update_ui()
        
        # Send serial notification
        if self.serial_handler:
            self.serial_handler.send(bytes([0x04]))  # Mode 04 - Clear DTCs

    def clear_stored(self):
        self.fault_manager.clear_stored()
        self.update_ui()
        
        # Send serial notification
        if self.serial_handler:
            self.serial_handler.send(bytes([0x04]))  # Mode 04 - Clear DTCs

    def filter_stored_dtcs(self, event=None):
        search_term = self.search_entry.get().lower()
        self.stored_list.configure(state="normal")
        self.stored_list.delete("1.0", "end")
        
        for code, data in self.fault_manager.stored_dtc.items():
            if search_term in code.lower() or search_term in data['description'].lower():
                color = SEVERITY_COLORS.get(data["severity"], "white")
                self.stored_list.insert("end", f"{code}: {data['description']}\n\n", code)
                self.stored_list.tag_config(code, foreground=color)
        
        self.stored_list.configure(state="disabled")

    def update_counts(self):
        self.active_count.configure(text=f"Active: {len(self.fault_manager.active_dtc)}")
        self.stored_count.configure(text=f"Stored: {len(self.fault_manager.stored_dtc)}")

    def update_ui(self):
        # Update active DTCs
        self.active_list.configure(state="normal")
        self.active_list.delete("1.0", "end")
        
        for code, data in self.fault_manager.active_dtc.items():
            color = SEVERITY_COLORS.get(data["severity"], "white")
            self.active_list.insert("end", f"{code}: {data['description']}\n", code)
            self.active_list.tag_config(code, foreground=color)
        
        # Update stored DTCs
        self.stored_list.configure(state="normal")
        self.stored_list.delete("1.0", "end")
        
        for code, data in self.fault_manager.stored_dtc.items():
            color = SEVERITY_COLORS.get(data["severity"], "white")
            self.stored_list.insert("end", f"{code}: {data['description']}\n", code)
            self.stored_list.tag_config(code, foreground=color)
        
        self.active_list.configure(state="disabled")
        self.stored_list.configure(state="disabled")
        self.update_counts()
        
        # Auto-refresh every 5 seconds
        self.after(5000, self.update_ui)

    def process_serial_command(self, mode, pid=None):
        """Handle serial requests for DTC information"""
        if mode == 0x03:  # Request stored DTCs
            dtc_codes = list(self.fault_manager.stored_dtc.keys())
            
            # Format response (max 3 DTCs)
            response = bytearray([0x03, len(dtc_codes)])
            for code in dtc_codes[:3]:  # Only send first 3 DTCs
                # Convert DTC code to bytes (e.g., "P0123" -> 0x01, 0x23)
                dtc_bytes = self._dtc_to_bytes(code)
                response.extend(dtc_bytes)
            
            # Pad with zeros if less than 3 DTCs
            while len(response) < 8:  # 2 header + 6 DTC bytes
                response.extend([0x00])
                
            return bytes(response)
            
        elif mode == 0x04:  # Clear DTCs
            self.clear_active()
            self.clear_stored()
            return bytes([0x04, 0x01])  # Success response
            
        return None

    def _dtc_to_bytes(self, dtc_code):
        """Convert DTC string (e.g., 'P0123') to 2-byte representation"""
        if len(dtc_code) != 5:
            return bytes([0x00, 0x00])
            
        # First character (P, C, B, U)
        first_char = dtc_code[0].upper()
        char_map = {'P': 0, 'C': 1, 'B': 2, 'U': 3}
        first_byte = char_map.get(first_char, 0)
        
        # Next two digits (00-99)
        digit1 = int(dtc_code[1])
        digit2 = int(dtc_code[2])
        first_byte |= (digit1 << 4)
        first_byte |= digit2
        
        # Last two digits (00-99)
        digit3 = int(dtc_code[3])
        digit4 = int(dtc_code[4])
        second_byte = (digit3 << 4) | digit4
        
        return bytes([first_byte, second_byte])